# OpenManus 架构文档

## 简介

OpenManus 是一个智能助手系统，能够理解用户的自然语言请求并执行各种任务。本文档详细描述了系统的设计和工作原理，适合各类读者阅读：
- **所有读者**：可以了解系统的基本功能和工作方式
- **开发者**：可以深入了解系统的技术细节和实现方式
- **贡献者**：可以理解如何扩展和改进系统

本文档采用由浅入深的结构，前面的章节使用通俗易懂的语言解释系统概念，后面的章节则提供更多技术细节。文档中的每个部分都是独立的，读者可以根据兴趣选择阅读的内容。

## 目录

- [OpenManus 架构文档](#openmanus-架构文档)
  - [简介](#简介)
  - [目录](#目录)
  - [1. 系统概览](#1-系统概览)
    - [1.1 核心功能](#11-核心功能)
    - [1.2 系统特点](#12-系统特点)
    - [1.3 工作模式](#13-工作模式)
  - [2. 系统架构](#2-系统架构)
    - [2.1 核心组件](#21-核心组件)
    - [2.2 组件关系](#22-组件关系)
  - [3. 执行流程](#3-执行流程)
    - [3.1 基本执行模式](#31-基本执行模式)
    - [3.2 高级规划模式](#32-高级规划模式)
    - [3.3 两种模式的对比](#33-两种模式的对比)
  - [4. 技术实现](#4-技术实现)
    - [4.1 代理系统](#41-代理系统)
    - [4.2 工具系统](#42-工具系统)
    - [4.3 Flow系统](#43-flow系统)
    - [4.4 设计模式应用](#44-设计模式应用)
  - [5. 开发者参考](#5-开发者参考)
    - [5.1 类图](#51-类图)
      - [代理系统类图](#代理系统类图)
      - [Flow系统类图](#flow系统类图)
    - [5.2 关键类说明](#52-关键类说明)
      - [代理系统](#代理系统)
      - [工具系统](#工具系统)
      - [Flow系统](#flow系统)
    - [5.3 调用链](#53-调用链)
      - [基本执行模式调用链](#基本执行模式调用链)
      - [高级规划模式调用链](#高级规划模式调用链)
    - [5.4 扩展指南](#54-扩展指南)
      - [添加新工具](#添加新工具)
      - [创建新的Flow类型](#创建新的flow类型)
      - [自定义代理行为](#自定义代理行为)

## 1. 系统概览

### 1.1 核心功能

OpenManus 是一个基于大型语言模型(LLM)的智能助手系统，能够：

- **理解自然语言**：用户可以用日常语言描述需求
- **执行复杂任务**：从简单的信息查询到复杂的多步骤任务
- **使用多种工具**：包括代码执行、网页浏览、搜索、文件操作等
- **规划与执行**：能够分解复杂任务并逐步执行

### 1.2 系统特点

OpenManus 具有以下关键特点：

- **智能决策**：系统能够自主决定使用哪些工具和方法解决问题
- **灵活适应**：能够处理各种不同类型的任务和请求
- **可扩展性**：设计允许轻松添加新的工具和功能
- **错误恢复**：具有检测和处理执行过程中错误的能力
- **循环检测**：能够识别并避免陷入重复的执行模式

### 1.3 工作模式

OpenManus 提供两种主要的工作模式：

- **基本执行模式**（通过 `main.py`）：
  - 直接响应用户请求
  - 即时思考和行动
  - 适合简单到中等复杂度的任务

- **高级规划模式**（通过 `run_flow.py`）：
  - 先创建完整的执行计划，再逐步执行
  - 明确跟踪执行进度
  - 适合复杂的多步骤任务

## 2. 系统架构

### 2.1 核心组件

OpenManus 由以下核心组件构成：

- **代理系统**：负责理解用户请求、决策和执行
  - **Manus 代理**：系统的核心代理，协调整个执行过程
  - **记忆系统**：存储对话历史和执行状态
  - **LLM 接口**：与大型语言模型通信

- **工具系统**：提供各种功能工具
  - **Python执行**：执行Python代码
  - **浏览器控制**：操作网页浏览器
  - **搜索工具**：执行网络搜索
  - **文件操作**：保存和读取文件

- **Flow系统**：提供高级任务规划和执行
  - **规划工具**：创建和管理执行计划
  - **执行跟踪**：监控计划执行进度

### 2.2 组件关系

组件之间的关系如下：

- **代理系统**是核心，协调其他组件的工作
- **工具系统**为代理提供执行能力
- **Flow系统**在代理系统之上提供更高级的规划能力

这种分层设计使系统既简单又强大，能够处理从简单到复杂的各种任务。

## 3. 执行流程

### 3.1 基本执行模式

基本执行模式（通过 `main.py`）的工作流程：

1. **用户输入请求**：用户描述他们需要完成的任务
2. **思考阶段**：
   - 系统分析用户请求
   - 决定需要使用哪些工具
   - 规划如何解决问题
3. **行动阶段**：
   - 系统执行决定的操作
   - 使用选择的工具
   - 获取执行结果
4. **重复执行**：
   - 系统根据执行结果继续思考和行动
   - 直到任务完成或达到最大步骤数
5. **返回结果**：向用户展示执行结果

这种模式类似于人类解决问题的方式：思考一步，执行一步，然后根据结果继续。

#### 基本执行模式流程图

```
用户输入prompt
    │
    ▼
初始化代理状态
    │
    ▼
┌─► 执行步骤 ──┐
│   │          │
│   ▼          │
│  思考阶段     │
│   │          │
│   ▼          │
│ 是否需要行动? ┼─► 否 ─► 返回"无需行动"
│   │          │
│   ▼ 是       │
│  行动阶段     │
│   │          │
│   ▼          │
│ 执行工具调用   │
│   │          │
│   ▼          │
│ 记录执行结果   ├─► 是 ─► 结束循环
│   │          │
│   ▼ 否       │
│ 检查是否卡住   ├─► 是 ─► 添加特殊提示
│   │          │
└───┘          │
    ▼          │
 步骤数+1      │
    │          │
    ▼          │
步骤数是否达到最大?─► 是 ─► 结束循环
    │          │
    ▼ 否       │
    └──────────┘
    │
    ▼
返回结果汇总
```

#### 单步执行流程图

```
step()方法开始
    │
    ▼
调用think()方法
    │
    ▼
┌─ 是否有next_step_prompt? ─┐
│           │                │
│           ▼ 是             │
│   添加提示到消息历史        │
│           │                │
└───────────┘                │
            │                │
            ▼                │
    调用LLM的ask_tool方法     │
            │                │
            ▼                │
    记录LLM的思考和工具选择    │
            │                │
            ▼                │
┌─ 工具选择模式是"none"? ───┐ │
│           │               │ │
│           ▼ 是            │ │
│   处理无工具模式           │ │
│           │               │ │
└───────────┘               │ │
            │ 否             │ │
            ▼                │ │
    创建助手消息并添加到内存    │ │
            │                │ │
            ▼                │ │
┌─ 是否需要执行行动? ─────────┐ │
│           │                │ │
│           ▼ 否             │ │
│   返回False                │ │
│           │                │ │
└───────────┘                │ │
            │ 是             │ │
            ▼                │ │
    返回True                 │ │
            │                │ │
            ▼                │ │
think()方法结束               │ │
            │                │ │
            ▼                │ │
┌─ should_act是True? ──────┘ │
│           │                  │
│           ▼ 否               │
│   返回"无需行动"             │
│           │                  │
└───────────┘                  │
            │ 是               │
            ▼                  │
    调用act()方法              │
            │                  │
            ▼                  │
┌─ 是否有工具调用? ─────────────┘
│           │
│           ▼ 否
│   返回最后一条消息内容
│           │
└───────────┘
            │ 是
            ▼
    遍历所有工具调用
            │
            ▼
┌─────── 对每个工具调用 ───────┐
│           │                 │
│           ▼                 │
│   调用execute_tool方法      │
│           │                 │
│           ▼                 │
│   记录工具执行结果           │
│           │                 │
│   创建工具消息并添加到内存    │
│           │                 │
│   收集结果                  │
│           │                 │
└───────────┘                 │
            │                 │
            ▼                 │
    返回所有结果的组合         │
            │                 │
            ▼                 │
act()方法结束                 │
            │                 │
            ▼                 │
step()方法结束                │
```

### 3.2 高级规划模式

高级规划模式（通过 `run_flow.py`）的工作流程：

1. **用户输入请求**：用户描述他们需要完成的任务
2. **创建计划**：
   - 系统分析整个任务
   - 创建完整的执行计划，包含多个步骤
3. **逐步执行**：
   - 系统按顺序执行计划中的每个步骤
   - 每个步骤都有明确的目标和状态
4. **跟踪进度**：
   - 系统记录每个步骤的执行状态
   - 可以清楚地看到整体进度
5. **完成计划**：
   - 所有步骤执行完毕后，生成执行摘要
   - 向用户展示最终结果

这种模式类似于项目管理：先制定完整计划，然后按计划执行。

#### 高级规划模式流程图

```
用户输入prompt
    │
    ▼
创建Manus代理
    │
    ▼
创建Flow实例
    │
    ▼
┌─► 创建初始计划 ──┐
│   │              │
│   ▼              │
│ 使用LLM分析任务   │
│   │              │
│   ▼              │
│ 生成步骤列表      │
│   │              │
└───┘              │
    │              │
    ▼              │
┌─► 执行计划循环 ───┐
│   │              │
│   ▼              │
│ 获取当前步骤      │
│   │              │
│   ▼              │
│ 是否还有步骤?    ┼─► 否 ─► 完成计划
│   │              │         │
│   ▼ 是           │         ▼
│ 选择执行代理      │       生成摘要
│   │              │         │
│   ▼              │         ▼
│ 执行当前步骤      │       返回结果
│   │              │
│   ▼              │
│ 标记步骤完成      │
│   │              │
└───┘              │
    │              │
    ▼              │
返回执行结果        │
```

### 3.3 两种模式的对比

|特性|基本执行模式|高级规划模式|
|---|---|---|
|适用场景|简单到中等复杂度任务|复杂的多步骤任务|
|执行方式|即时思考和行动|先规划后执行|
|任务分解|隐式分解|明确分解为步骤|
|进度跟踪|基于内存中的历史|明确的步骤状态|
|多代理支持|单一代理|支持多个专业代理|
|上下文管理|基于历史记录|为每个步骤提供计划上下文|

## 4. 技术实现

### 4.1 代理系统

代理系统基于"思考-行动"循环模式（ReAct模式），主要包括：

- **BaseAgent**：提供基础功能，包括状态管理和执行循环
- **ReActAgent**：实现思考-行动循环的抽象基类
- **ToolCallAgent**：处理工具调用的代理实现
- **Manus**：最终用户使用的代理，集成所有功能

代理执行过程：
1. 接收用户请求
2. 进入执行循环
3. 每个循环包含思考和行动两个阶段
4. 思考阶段决定下一步行动
5. 行动阶段执行决定的操作
6. 循环直到任务完成

### 4.2 工具系统

工具系统提供各种功能，主要包括：

- **BaseTool**：所有工具的抽象基类
- **ToolCollection**：管理多个工具的集合
- **具体工具**：
  - **PythonExecute**：执行Python代码
  - **BrowserUseTool**：控制网页浏览器
  - **GoogleSearch**：执行Google搜索
  - **FileSaver**：保存文件
  - **Terminate**：终止执行

工具执行过程：
1. 代理决定使用某个工具
2. 准备工具参数
3. 调用工具的execute方法
4. 获取执行结果
5. 将结果添加到代理的记忆中

### 4.3 Flow系统

Flow系统提供高级任务规划和执行，主要包括：

- **BaseFlow**：所有Flow的抽象基类
- **FlowFactory**：创建不同类型的Flow
- **PlanningFlow**：实现规划和执行的Flow
- **PlanningTool**：创建和管理执行计划

Flow执行过程：
1. 创建初始计划
2. 获取当前需要执行的步骤
3. 选择合适的代理执行步骤
4. 标记步骤为已完成
5. 继续执行下一个步骤
6. 所有步骤完成后，生成执行摘要

### 4.4 设计模式应用

OpenManus系统使用了多种设计模式，使其具有高度的灵活性和可扩展性：

- **策略模式**：不同的工具实现相同的接口，可以互换使用
- **组合模式**：工具集合组合多个工具，提供统一的接口
- **模板方法模式**：基类定义算法骨架，子类实现特定步骤
- **状态模式**：使用状态对象管理代理的不同状态
- **命令模式**：工具调用封装了请求为对象
- **单例模式**：LLM类使用单例模式确保只有一个实例
- **工厂模式**：FlowFactory用于创建不同类型的Flow
- **观察者模式**：Flow系统中的步骤执行状态变化通知

## 5. 开发者参考

### 5.1 类图

#### 代理系统类图

```
+-------------------+     +-------------------+     +-------------------+
|    BaseAgent      |     |      Memory       |     |       LLM         |
+-------------------+     +-------------------+     +-------------------+
| - name: str       |     | - messages: List  |     | - model: str      |
| - description: str|     +-------------------+     | - max_tokens: int |
| - system_prompt   |     | + add_message()   |     | - temperature: float|
| - next_step_prompt|     | + clear()         |     +-------------------+
| - llm: LLM        |<>---| + get_messages()  |     | + ask()           |
| - memory: Memory  |     +-------------------+     | + ask_tool()      |
| - state: AgentState|                              | + format_messages()|
| - max_steps: int  |                              +-------------------+
| - current_step: int|
+-------------------+
| + run()           |
| + step()          |
| + update_memory() |
| + state_context() |
+-------------------+
        ^
        |
+-------------------+
|    ReActAgent     |
+-------------------+
| + think()         |<----(abstract)
| + act()           |<----(abstract)
| + step()          |
+-------------------+
        ^
        |
+-------------------+     +-------------------+
|   ToolCallAgent   |     |  ToolCollection   |
+-------------------+     +-------------------+
| - tool_choices    |<>---| - tool_map: Dict  |
| - special_tool_names|    +-------------------+
| - tool_calls: List|     | + execute()       |
| - max_steps: int  |     | + to_params()     |
+-------------------+     +-------------------+
| + think()         |             ^
| + act()           |             |
| + execute_tool()  |     +-------------------+
| + _handle_special_tool()|      BaseTool     |
+-------------------+     +-------------------+
        ^                 | - name: str       |
        |                 | - description: str|
+-------------------+     | - parameters: dict|
|      Manus        |     +-------------------+
+-------------------+     | + execute()       |<----(abstract)
| - name: str       |     +-------------------+
| - description: str|             ^
| - system_prompt   |             |
| - next_step_prompt|    +--------+--------+--------+--------+--------+
| - available_tools |    |                 |        |        |        |
+-------------------+    v                 v        v        v        v
                    +----------+  +-------------+ +-----+ +--------+ +--------+
                    |PythonExecute| |BrowserUseTool| |Google| |FileSaver| |Terminate|
                    +----------+  +-------------+ |Search| +--------+ +--------+
```

#### Flow系统类图

```
+-------------------+     +-------------------+
|     BaseFlow      |     |   FlowFactory     |
+-------------------+     +-------------------+
| - agents: Dict    |     | + create_flow()   |
| - tools: List     |     +-------------------+
| - primary_agent_key|            |
+-------------------+            |
| + primary_agent   |            |
| + get_agent()     |            |
| + add_agent()     |            |
| + execute()       |<----(abstract)
+-------------------+
        ^
        |
+-------------------+     +-------------------+
|   PlanningFlow    |     |   PlanningTool    |
+-------------------+     +-------------------+
| - llm: LLM        |<>---| - plans: Dict     |
| - planning_tool   |     | + execute()       |
| - executor_keys   |     | + to_param()      |
| - active_plan_id  |     +-------------------+
| - current_step_idx|
+-------------------+
| + execute()       |
| + _create_initial_plan() |
| + _get_current_step_info() |
| + _execute_step() |
+-------------------+
```

### 5.2 关键类说明

#### 代理系统

- **BaseAgent**：提供代理的基础功能
  - 管理状态和内存
  - 提供执行循环框架
  - 定义抽象的步骤执行方法

- **ReActAgent**：实现思考-行动循环
  - 定义抽象的思考和行动方法
  - 实现步骤执行逻辑

- **ToolCallAgent**：处理工具调用
  - 实现思考方法，调用LLM并处理响应
  - 实现行动方法，执行工具调用
  - 处理特殊工具的执行

- **Manus**：最终用户使用的代理
  - 设置系统提示和下一步提示
  - 配置可用工具集合

#### 工具系统

- **BaseTool**：工具的抽象基类
  - 定义工具接口
  - 提供参数验证

- **ToolCollection**：管理多个工具
  - 存储工具映射
  - 提供工具执行接口
  - 转换工具参数格式

- **具体工具类**：实现特定功能
  - 各自实现execute方法
  - 处理特定领域的任务

#### Flow系统

- **BaseFlow**：Flow的抽象基类
  - 管理代理集合
  - 提供代理访问接口
  - 定义抽象的执行方法

- **FlowFactory**：创建Flow实例
  - 根据类型创建不同的Flow

- **PlanningFlow**：实现规划和执行
  - 创建初始计划
  - 管理步骤执行
  - 跟踪执行进度

- **PlanningTool**：创建和管理计划
  - 存储计划数据
  - 提供计划操作接口

### 5.3 调用链

#### 基本执行模式调用链

```
main.py: main() 
  → asyncio.run(main_async())
    → Manus.run(prompt)  # BaseAgent.run的实现
      → BaseAgent.update_memory("user", prompt)  # 记录用户请求
      → BaseAgent.state_context(AgentState.RUNNING)  # 状态管理
        → while循环(current_step < max_steps && state != FINISHED)
          → BaseAgent.step()  # 调用ReActAgent.step的实现
            → ReActAgent.think()  # 调用ToolCallAgent.think的实现
              → LLM.ask_tool(...)  # 调用LLM接口
                → AsyncOpenAI.chat.completions.create(...)  # 调用OpenAI API
              → Memory.add_message(...)  # 记录LLM响应
            → ReActAgent.act()  # 调用ToolCallAgent.act的实现
              → ToolCallAgent.execute_tool(...)  # 执行工具调用
                → ToolCollection.execute(...)  # 调用工具集合
                  → BaseTool.execute(...)  # 调用具体工具
              → Memory.add_message(...)  # 记录工具执行结果
```

#### 高级规划模式调用链

```
run_flow.py: run_flow() 
  → asyncio.run(run_flow_async())
    → Manus()  # 创建代理实例
    → FlowFactory.create_flow(...)  # 创建Flow实例
      → PlanningFlow(...)  # 创建PlanningFlow实例
    → flow.execute(prompt)  # 执行Flow
      → _create_initial_plan(...)  # 创建初始计划
        → LLM.ask_tool(...)  # 调用LLM创建计划
        → planning_tool.execute(...)  # 执行规划工具
      → while循环
        → _get_current_step_info()  # 获取当前步骤
        → get_executor(...)  # 获取执行代理
        → _execute_step(...)  # 执行步骤
          → executor.run(...)  # 调用代理执行
          → _mark_step_completed()  # 标记步骤完成
```

### 5.4 扩展指南

OpenManus系统设计为高度可扩展，可以通过以下方式进行扩展：

#### 添加新工具

1. 创建新的工具类，继承自BaseTool
2. 实现execute方法，提供工具功能
3. 在Manus类中添加新工具到available_tools

```python
class NewTool(BaseTool):
    name: str = "new_tool"
    description: str = "Description of the new tool"
    parameters: dict = {
        # 定义参数
    }
    
    async def execute(self, **kwargs) -> Any:
        # 实现工具功能
        pass
```

#### 创建新的Flow类型

1. 创建新的Flow类，继承自BaseFlow
2. 实现execute方法，提供Flow功能
3. 在FlowFactory中注册新的Flow类型

```python
class NewFlow(BaseFlow):
    # 定义属性
    
    async def execute(self, input_text: str) -> str:
        # 实现Flow功能
        pass
```

#### 自定义代理行为

1. 创建新的代理类，继承自现有代理类
2. 重写think和act方法，提供自定义行为
3. 使用新的代理类替代Manus

```python
class CustomAgent(ToolCallAgent):
    # 定义属性
    
    async def think(self) -> bool:
        # 实现自定义思考逻辑
        pass
        
    async def act(self) -> str:
        # 实现自定义行动逻辑
        pass
```

通过这些扩展方式，OpenManus系统可以适应各种不同的应用场景和需求。 